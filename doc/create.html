<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Salt: Create a Salt model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="salt.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Salt
   &#160;<span id="projectnumber">3.3.6</span>
   </div>
   <div id="projectbrief">A powerful, tagset-independent and theory-neutral meta model and API for storing, manipulating, and representing nearly all types of linguistic data .</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('create.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Create a Salt model </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this article, we present a very simple example to show how to create a Salt model in a very brief way. The example is given to clarify the mechanisms of Salt and therefore does not claim to advocate a specific linguistic school.</p>
<h3><a class="anchor" id="corpusStructure"></a>Corpus Structure</h3>
<p>Due to its graph-based structure, even sub- and super-corpora are modeled as nodes having relations connecting them and creating a containment relationship. The only element not following the graph approach is the element <em>SaltProject</em>. This element serves as container for a set of corpus structures represented via the model element <em>SCorpusGraph</em>. Such a corpus structure is organized as a graph and contains corpora and documents. Salt distinguishes between a corpus (which can contain other corpora and documents) and documents (which only contain the document structure). The document structure itself is organized as a graph called <em>SDocumentGraph</em>. The <em>SDocumentGraph</em> is the element containing the primary data and the linguistic analysis. The corpus structure is just for organizing a complex linguistic project. A corpus in Salt is represented by the element <em>SCorpus</em> and a document is represented by the element <em>SDocument</em>. In this section, we create a simple corpus structure having one corpus and one document. Since corpora and documents are nodes, they can be labeled. To show this mechanism, we create a meta annotation, defining the annotator of that corpus. A meta annotation is represented via the element <em>SMetaAnnotation</em>. The corpus structure created here is shown in the figure below.</p>
<div class="image">
<img src="corpusStructure.png" alt="corpusStructure.png"/>
</div>
<p>The following snippet shows the creation of the container object <em>SaltProject</em>, which shall contain our corpus model.</p>
<div class="fragment"><div class="line">SaltProject saltProject= SaltFactory.createSaltProject();</div></div><!-- fragment --><p>The next snippet illustrates the creation of the corpus structure by creating a corpus graph, a corpus named 'sampleCorpus' and a document named 'sampleDocument'. Afterwards, the creation of the corpus is shown, followed by a meta annotation declaring its annotator.</p>
<div class="fragment"><div class="line"><span class="comment">//creates a new corpus structure</span></div><div class="line">SCorpusGraph corpGraph= saltProject.createCorpusGraph();</div><div class="line"><span class="comment">//adds a corpus with name sampleCorpus to the corpus structure</span></div><div class="line">SCorpus sampleCorpus= corpGraph.createCorpus(URI.createURI(<span class="stringliteral">&quot;/sampleCorpus&quot;</span>)).<span class="keyword">get</span>(0);</div></div><!-- fragment --><p>The meta annotation is created via the method <em>createSMetaAnnotation()</em>. This method takes three arguments: a namespace which is optional and can be used to take up further information, the name of the annotation and the value of the annotation.</p>
<div class="fragment"><div class="line"><span class="comment">//creates a meta annotation on the corpus sampleCorpus</span></div><div class="line">sampleCorpus.createMetaAnnotation(null, <span class="stringliteral">&quot;annotator&quot;</span>, <span class="stringliteral">&quot;A. Nyone&quot;</span>);</div></div><!-- fragment --><p>We now create the document that will later contain a primary text and all of its annotations. We present two ways of creating a document. First an easier way, where we use helpful methods provided by Salt and second an alternative, where we do it manually.</p>
<div class="fragment"><div class="line"><span class="comment">//creates a new document named sampleDocument, and adds it as part of sampleCorpus</span></div><div class="line">SDocument sampleDocument=  corpGraph.createDocument(URI.createURI(<span class="stringliteral">&quot;/sampleCorpus/sampleDocument&quot;</span>));</div></div><!-- fragment --><h4>Alternative</h4>
<p>Alternatively you can add an already existing document to the corpus structure and use the <em>addDocument</em> method. </p><div class="fragment"><div class="line">SDocument sampleDocument= SaltFactory.createSDocument();</div><div class="line">sampleDocument.setName(<span class="stringliteral">&quot;sampleDocument&quot;</span>);</div><div class="line"><span class="comment">//adds the document to the graph and automatically creates an relations between the corpus and the document</span></div><div class="line">corpGraph.addDocument(sampleCorpus, sampleDocument);&lt;/pre&gt;</div></div><!-- fragment --><h3><a class="anchor" id="documentStructure"></a>Document Structure</h3>
<p>Now we are leaving the corpus structure and go to the document structure. The difference between both is that the corpus structure groups corpora and documents to super- and sub-corpora and documents, and the document structure contains primary data and their annotations. Therefore we need to add an <em>SDocumentGraph</em> object to the <em>SDocument</em>, which acts as container for the primary data and linguistic annotations.</p>
<div class="fragment"><div class="line">sampleDocument.setDocumentGraph(SaltFactory.createSDocumentGraph());</div></div><!-- fragment --><h3>Primary Data</h3>
<p>We now show how to add a primary text like "Is this example more complicated than it appears to?" to the document graph. We first show the easy way of creating primary data and than we show the more explicit way.</p>
<div class="fragment"><div class="line">STextualDS primaryText = sampleDocument.getDocumentGraph().createTextualDS(<span class="stringliteral">&quot;Is this example more complicated than it appears to be?&quot;</span>);</div></div><!-- fragment --><p>Even the primary text and in general the primary data in Salt are modeled as nodes with labels. The specific node, which is the container for the primary text is the node <em>STextualDS</em>, which is a subclass of <em>SSequentialDS</em>. The <em>String</em> representing the text is stored in a label of that node, which can be accessed via <em>STextualDS.getSText()</em> or <em>STextualDS.setSText(text)</em>.</p>
<h4>Alternative</h4>
<div class="fragment"><div class="line"><span class="comment">// set the primary text to the sentence</span></div><div class="line"><span class="comment">// &quot;Is this example more complicated than it appears to be?&quot;</span></div><div class="line">primaryText.setText(<span class="stringliteral">&quot;Is this example more complicated than it appears to be?&quot;</span>);</div><div class="line"><span class="comment">// add the text to the document-graph</span></div><div class="line">sampleDocument.getDocumentGraph().addNode(primaryText);</div></div><!-- fragment --><h3><a class="anchor" id="tokenization"></a>Tokenization</h3>
<p>Sometimes it might be necessary to manually tokenize a text yourself. For instance if you don't want to have a word tokenization, or for historical text, where separators are missing.</p>
<p>A token in Salt is not bound to a linguistic unit - in this example we show how to tokenize words, although tokenizations by characters, syllables or sentences and so on are possible, too. The following figure shows an excerpt of the document graph we want to model in Salt. The figure only shows the tokens overlapping the words 'Is', 'this', 'example' and '.'.</p>
<div class="image">
<img src="sample_tokenization.png" alt="sample_tokenization.png"/>
</div>
<p>For tokenizing a primary text, we need the character offset of the start and the end position for each token in the text. The word "Is" in the sample text, for instance, has the start position 0 and the end position 2. Note that the positions are counted <b>between</b> two characters.</p>
<table class="doxtable">
<tr>
<td></td><td>Is</td><td></td><td>BLANK</td><td></td><td>this</td><td></td><td>BLANK</td><td></td><td>example</td><td></td><td>BLANK</td><td></td><td>more</td><td></td><td>BLANK</td><td></td><td>complicated</td><td></td><td>BLANK</td><td></td><td>than</td><td></td><td>BLANK</td><td></td><td>it</td><td></td><td>BLANK</td><td></td><td>appears</td><td></td><td>BLANK</td><td></td><td>to</td><td></td><td>BLANK</td><td></td><td>be</td><td></td><td>?</td><td></td></tr>
<tr>
<td>0</td><td></td><td>2</td><td></td><td>3</td><td></td><td>7</td><td></td><td>8</td><td></td><td>15</td><td></td><td>16</td><td></td><td>20</td><td></td><td>21</td><td></td><td>32</td><td></td><td>33</td><td></td><td>37</td><td></td><td>38</td><td></td><td>40</td><td></td><td>41</td><td></td><td>48</td><td></td><td>49</td><td></td><td>51</td><td></td><td>52</td><td></td><td>54</td><td>55  </td></tr>
</table>
<p>In the given table, BLANK is an alias for the whitespace character (' ').</p>
<p>Salt provides a tokenizer to tokenize a primary text. This tokenizer is an adaptation of the TreeTagger tokenizer (see: <a href="http://www.cis.uni-muenchen.de/~schmid/tools/TreeTagger/">http://www.cis.uni-muenchen.de/~schmid/tools/TreeTagger/</a>). The tokenizer uses blanks and punctuation (taking abbreviations into account), and so on, to separate words. The usage of the tokenizer is quite simple as the following snippet shows:</p>
<div class="fragment"><div class="line">sampleDocument.getDocumentGraph().tokenize();</div></div><!-- fragment --><p>To access the created tokens you can iterate over the token's list:</p>
<div class="fragment"><div class="line">sampleDocument.getSDocumentGraph().getTokens();</div></div><!-- fragment --><p>or token by token:</p>
<div class="fragment"><div class="line">sampleDocument.getDocumentGraph().getTokens().get(0);</div></div><!-- fragment --><p>In the following snippet we show an example of creating a tokenization manually by creating just one token. The creation of all other tokens is done in the same manner.</p>
<div class="fragment"><div class="line"><span class="comment">//create tokens manually </span></div><div class="line">SToken tok_is= sampleDocument.getDocumentGraph().createToken(primaryText, 0, 2);</div><div class="line">SToken tok_this= sampleDocument.getDocumentGraph().createToken(primaryText, 3, 7);</div><div class="line">SToken tok_example= sampleDocument.getDocumentGraph().createToken(primaryText, 8, 15);</div><div class="line">SToken tok_more= sampleDocument.getDocumentGraph().createToken(primaryText, 16, 20);</div><div class="line">SToken tok_complicated= sampleDocument.getDocumentGraph().createToken(primaryText, 21, 32);</div><div class="line">SToken tok_than= sampleDocument.getDocumentGraph().createToken(primaryText, 33, 37);</div><div class="line">SToken tok_it= sampleDocument.getDocumentGraph().createToken(primaryText, 38, 41);</div><div class="line">SToken tok_appears= sampleDocument.getDocumentGraph().createToken(primaryText, 42, 48);</div><div class="line">SToken tok_to= sampleDocument.getDocumentGraph().createToken(primaryText, 49, 51);</div><div class="line">SToken tok_be= sampleDocument.getDocumentGraph().createToken(primaryText, 52, 54);</div><div class="line">SToken tok_PUNC= sampleDocument.getDocumentGraph().createToken(primaryText, 54, 55);</div></div><!-- fragment --><p> Now the token will be added to the morphology layer. A layer in Salt is represented by the element <em>SLayer</em> and defines a kind of a sub-graph, for instance for clustering nodes in a specific linguistic analysis. The snippet also shows the annotation of tokens with part-of-speech and lemma annotations using the element <em>SAnnotation</em>.</p>
<div class="fragment"><div class="line"><span class="comment">//creating a layer named morphology</span></div><div class="line">SLayer morphLayer = SaltFactory.createSLayer();</div><div class="line">morphLayer.setName(<span class="stringliteral">&quot;morphology&quot;</span>);</div><div class="line">sampleDocument.addLayer(morphLayer);</div><div class="line"></div><div class="line"><span class="comment">//adding the new token to the morphology layer</span></div><div class="line">morphLayer.addNode(tok_is);</div><div class="line"><span class="comment">//adding a part-of-speech annotation to the new token</span></div><div class="line">tok_is.createAnnotation(null, <span class="stringliteral">&quot;pos&quot;</span>, <span class="stringliteral">&quot;VBZ&quot;</span>);</div><div class="line"><span class="comment">//adding a lemma annotation to the new token</span></div><div class="line">tok_is.createAnnotation(null, <span class="stringliteral">&quot;lemma&quot;</span>, <span class="stringliteral">&quot;be&quot;</span>);</div><div class="line"><span class="comment">//...</span></div></div><!-- fragment --><p>Again, we did not explicitly create the relations: their creation is hidden in the method <em>createSToken()</em>. But in the background Salt creates a node of type <em>SToken</em> for the token and a relation called <em>STextualRelation</em> which connects the token and the primary data node. Since Salt does not know any further elements other than the graph elements mentioned, the character positions, to which the tokens refer, are stored as labels of the relations. For such a kind of label we use a special type named <em>SFeature</em>. When just working with Salt and not creating an own derived meta model, the mechanism is not important. It is just important, that the positions can be set and retrieved via the methods <em>STextualRelation.getSStart()</em> or <em>STextualRelation.setSStart(value)</em>. The same goes for the end position <em>SEnd</em>.</p>
<h3><a class="anchor" id="hierarchies"></a>Hierarchies</h3>
<p>In Salt you can create hierarchies, e.g., in order to model syntactic annotations such as constituents. These hierarchies are realized via the node <em>SStructure</em> and can be connected to each other via relations of type <em>SDominanceRelation</em>. A relation of that type has the semantics of a part-of relation, which means that the target of that relation is a part of the source of that relation. In this example, we want to create a syntactic analysis as part of a syntactic layer. The following figure shows the structure we will create in this step of the example.</p>
<div class="fragment"><div class="line">                     ROOT-----------------                  </div><div class="line">                      |                   \</div><div class="line">               -------SQ ---               \</div><div class="line">              /    /        \               \</div><div class="line">             /    /          ---ADJP--       \</div><div class="line">            /    /          /         \       \</div><div class="line">           /    /          /           SBar    \</div><div class="line">          /    /          /           /    \    \</div><div class="line">         /    /          /           /      S    \</div><div class="line">        /    /          /           /      / \    \</div><div class="line">       /    /          /           /      /   VP   \</div><div class="line">      /    /          /           /      /  /   \   \</div><div class="line">     /    /          /           /      /   |    S   \</div><div class="line">    /    /           |           |     /    |     \   \</div><div class="line">   /    /            |           |    /     |      VP  \</div><div class="line">  /    NP           ADJA         |    NP    |     /  \  \</div><div class="line"> /    /   \       /      \       |    |     |     |  VP |</div><div class="line"> |    |   |       |      |       |    |     |     |  |  |</div><div class="line">Is <span class="keyword">this</span> example more complicated than it appears to be  ?</div></div><!-- fragment --><p>The following snippet gives an impression of how to create that hierarchy. We just show the creation of the left NP node and the SQ node.</p>
<div class="fragment"><div class="line"><span class="comment">//create a list of nodes, which shall be overlapped by the NP-node</span></div><div class="line">List&lt;SStructuredNode&gt; overlappingNodes= <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">overlappingNodes.add(tok_this);</div><div class="line">overlappingNodes.add(tok_example);</div><div class="line"><span class="comment">//adding NP-Node to graph and automatically creating relations to overlapping nodes</span></div><div class="line">SStructure np_1= sampleDocument.getDocumentGraph().createStructure(overlappingNodes);</div><div class="line">np_1.createAnnotation(null, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;NP&quot;</span>);</div><div class="line"><span class="comment">//...</span></div><div class="line"></div><div class="line"><span class="comment">//create a list of nodes, which shall be overlapping by SQ-node</span></div><div class="line">overlappingNodes= <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">overlappingNodes.add(tok_is);</div><div class="line">overlappingNodes.add(np_1);</div><div class="line">SStructure sq= sampleDocument.getDocumentGraph().createStructure(overlappingNodes);</div><div class="line">sq.createAnnotation(null, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;SQ&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">//create a syntax layer</span></div><div class="line">SLayer syntaxLayer = SaltFactory.createSLayer();</div><div class="line">syntaxLayer.setName(<span class="stringliteral">&quot;syntax&quot;</span>);</div><div class="line">sampleDocument.getDocumentGraph().addLayer(syntaxLayer);</div><div class="line"></div><div class="line"><span class="comment">//add syntactic nodes to syntax layer</span></div><div class="line">syntaxLayer.addNode(np_1);</div><div class="line">syntaxLayer.addNode(sq);</div><div class="line"><span class="comment">//...</span></div></div><!-- fragment --><p>For annotating a dominance relation or any other relation, you can access it by querying all relations between two nodes:</p>
<pre>
sampleDocument.getDocumentGraph().getRelations(np_1.getId(), tok_is.getId()).get(0).createAnnotation("myNamespace", "myName", "myValue");
</pre><h4>Alternative</h4>
<p>Alternatively, you can create a hierarchy one step after another. The following snippet exemplifies this process for the same sample (the token for 'is' and the SQ node):</p>
<div class="fragment"><div class="line">SStructure sq = SaltFactory.createSStructure();</div><div class="line">sampleDocument.getDocumentGraph().addNode(sq);</div><div class="line">sq.createAnnotation(null, <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;SQ&quot;</span>);</div><div class="line"></div><div class="line">SDominanceRelation domRel = SaltFactory.createSDominanceRelation();</div><div class="line">domRel.setSource(sq);</div><div class="line">domRel.setTarget(tok_is);</div><div class="line">sampleDocument.getDocumentGraph().addRelation(domRel);</div></div><!-- fragment --><h3><a class="anchor" id="spans"></a>Spans</h3>
<p>If a whole (possibly discontinuous) set of nodes has to be annotated with the very same annotation, a span can be used to aggregate the nodes. Instead of an annotation for each node, a single annotation for the span can be created then. This annotation belongs to the set of nodes (the span), but not to any of the single nodes. In our example we show the use of spans building an information structure analysis. Spans in Salt are realized by nodes of the type <em>SSpan</em>, they are connected to <em>SToken</em> nodes via relations of type <em>SSpanningRelation</em>. The following figure shows the information structure analysis to be modeled.</p>
<div class="image">
<img src="sample_span.png" alt="sample_span.png"/>
</div>
<p>The following snippet shows the code used to create the analysis shown in the figure.</p>
<div class="fragment"><div class="line"><span class="comment">//create span overlaping only one token</span></div><div class="line">SSpan contrast_focus= sampleDocument.getDocumentGraph().createSpan(tok_is);</div><div class="line">contrast_focus.createAnnotation(null, <span class="stringliteral">&quot;inf-struct&quot;</span>, <span class="stringliteral">&quot;contrast-focus&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">//create a list of tokens taking part in the set to be annotated as a bundle</span></div><div class="line">List&lt;SToken&gt; overlappingTokens= <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">overlappingTokens.add(tok_this);</div><div class="line">overlappingTokens.add(tok_example);</div><div class="line">overlappingTokens.add(tok_more);</div><div class="line">overlappingTokens.add(tok_complicated);</div><div class="line">overlappingTokens.add(tok_than);</div><div class="line">overlappingTokens.add(tok_it);</div><div class="line">overlappingTokens.add(tok_appears);</div><div class="line">overlappingTokens.add(tok_to);</div><div class="line">overlappingTokens.add(tok_be);</div><div class="line">overlappingTokens.add(tok_PUNC);</div><div class="line"></div><div class="line"><span class="comment">//create span overlaping a set of tokens        </span></div><div class="line">SSpan topic= sampleDocument.getDocumentGraph().createSpan(overlappingTokens);</div><div class="line">topic.createAnnotation(null, <span class="stringliteral">&quot;inf-struct&quot;</span>, <span class="stringliteral">&quot;topic&quot;</span>);</div></div><!-- fragment --><h4>Alternative</h4>
<p>Alternatively to using the method createSSpan(...) you can create the span and the corresponding <em>SSpanningRelations</em> on your own. The following snippet gives an impression of how to create the same span as in the last example, step by step:</p>
<div class="fragment"><div class="line">SSpan contrast_focus= SaltFactory.createSSpan();</div><div class="line">sampleDocument.getDocumentGraph().addNode(contrast_focus);</div><div class="line">SSpanningRelation spanRel= SaltFactory.createSSpanningRelation();</div><div class="line">spanRel.setSource(contrast_focus);</div><div class="line">spanRel.setTarget(tok_is);</div></div><!-- fragment --><h3><a class="anchor" id="pointingRelations"></a>Pointing Relations</h3>
<p>Now we will show another type of relation, which renders a more loose relation between nodes. In contrast to <em>SSpanningRelations</em> and <em>SDominanceRelations</em>, which can only connect specific kinds of nodes, the type <em>SPointingRelation</em> can connect <em>SToken</em>, <em>SSpan</em> and <em>SStructure</em> nodes with each other and vice versa. These relations for instance can be used to model anaphoric relations between words, phrases, sentences and so on. Relations in general can be typed with a linguistic meaning by setting their attribute <em>SType</em>. We illustrate that by connecting the token covering the word "it" to the set of tokens "the" and "example". To bundle the words "the" and "example", we first have to create a span covering both tokens "the" and "example" following the same mechanism as shown in section <a href="#spans">Spans</a>.</p>
<div class="image">
<img src="sample_pointingRel.png" alt="sample_pointingRel.png"/>
</div>
<p>The following snippet shows the creation of the model shown in the figure.</p>
<div class="fragment"><div class="line"><span class="comment">//create a span covering the words &quot;the&quot; and &quot;example&quot;</span></div><div class="line">overlappingTokens= <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">overlappingTokens.add(tok_this);</div><div class="line">overlappingTokens.add(tok_example);</div><div class="line">SSpan span= sampleDocument.getDocumentGraph().createSpan(overlappingTokens);</div><div class="line"></div><div class="line"><span class="comment">//creating a pointing relations</span></div><div class="line">SPointingRelation pointingRelation= SaltFactory.createSPointingRelation();</div><div class="line"><span class="comment">//setting token &quot;it&quot; as source of this relation</span></div><div class="line">pointingRelation.setSource(tok_it);</div><div class="line"><span class="comment">//setting span &quot;this example&quot; as target of this relation</span></div><div class="line">pointingRelation.setTarget(span);</div><div class="line"><span class="comment">//adding the created relation to the document-graph</span></div><div class="line">sampleDocument.getDocumentGraph().addRelation(pointingRelation);</div><div class="line"><span class="comment">//adding the type to the relation</span></div><div class="line">pointingRelation.setType(<span class="stringliteral">&quot;anaphoric&quot;</span>);</div></div><!-- fragment --><p>You can download the demonstrated code via github under <a href="https://github.com/korpling/saltDemo">https://github.com/korpling/saltDemo</a>. More code samples can be found in Salt's sample package.</p>
<p>To learn how to access the elements of a Salt model, please read the article <a class="el" href="access.html">Access a Salt model</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Nov 9 2018 18:34:53 for Salt by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
